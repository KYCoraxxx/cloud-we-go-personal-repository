// Code generated by hertz generator.

package demo

import "C"
import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/common/adaptor"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"github.com/cloudwego/kitex/client"
	"github.com/cloudwego/kitex/client/genericclient"
	"github.com/cloudwego/kitex/pkg/connpool"
	"github.com/cloudwego/kitex/pkg/discovery"
	"github.com/cloudwego/kitex/pkg/generic"
	"github.com/cloudwego/kitex/pkg/rpcinfo"
	etcd "github.com/kitex-contrib/registry-etcd"
	"io/ioutil"
	"log"
	"time"
)

type randomBalancer struct{}

var registerClient genericclient.Client = nil
var queryClient genericclient.Client = nil
var registerProvider *generic.ThriftContentProvider
var queryProvider *generic.ThriftContentProvider

func getRegisterClient() *genericclient.Client {
	thrift, err := ioutil.ReadFile("../service/hello.thrift")
	if err != nil {
		panic(err)
	}

	thriftContent := string(thrift[:])

	if registerClient == nil {
		registerProvider, err = generic.NewThriftContentProvider(thriftContent, map[string]string{})
		if err != nil {
			panic(err)
		}

		g, err := generic.JSONThriftGeneric(registerProvider)
		if err != nil {
			panic(err)
		}

		r, err := etcd.NewEtcdResolver([]string{"127.0.0.1:2379"})
		if err != nil {
			log.Fatal(err)
		}

		filterFunc := func(ctx context.Context, instance []discovery.Instance) []discovery.Instance {
			var res []discovery.Instance
			for _, ins := range instance {
				if v, ok := ins.Tag("Cluster"); ok && v == "StudentCluster" {
					// only match tag with {tagKey: tagValues[0]}
					res = append(res, ins)
				}
			}
			return res
		}
		// Construct the filterRule
		filterRule := &FilterRule{Name: "rule-name", Funcs: []FilterFunc{filterFunc}}
		// build rule based resolver
		rbr := NewRuleBasedResolver(r, filterRule)

		// service discovery
		ctx := context.Background()
		ei := rpcinfo.NewEndpointInfo("StudentService", "", nil, nil)
		desc := rbr.Target(ctx, ei)
		res, err := rbr.Resolve(ctx, desc)
		if err != nil {
			panic(err)
		}

		// the instance should match the filter rule
		v, _ := res.Instances[0].Tag("Cluster")
		fmt.Println(fmt.Sprintf("[Resolver]: get instance with tag, [Cluster:%s]", v))

		cfg := connpool.IdleConfig{
			MaxIdlePerAddress: 1000,
			MaxIdleGlobal:     10000,
			MaxIdleTimeout:    60 * time.Second,
		}

		registerClient, err = genericclient.NewClient("StudentService", g,
			client.WithResolver(rbr), client.WithLoadBalancer(new(randomBalancer)), client.WithLongConnection(cfg))
		if err != nil {
			panic(err)
		}
	} else {
		err = registerProvider.UpdateIDL(thriftContent, map[string]string{})
		if err != nil {
			panic(err)
		}
	}
	return &registerClient
}

func getQueryRegister() *genericclient.Client {
	thrift, err := ioutil.ReadFile("../service/hello.thrift")
	if err != nil {
		panic(err)
	}

	thriftContent := string(thrift[:])

	if queryClient == nil {

		queryProvider, err = generic.NewThriftContentProvider(thriftContent, nil)
		if err != nil {
			panic(err)
		}

		g, err := generic.HTTPThriftGeneric(queryProvider)
		if err != nil {
			panic(err)
		}

		r, err := etcd.NewEtcdResolver([]string{"127.0.0.1:2379"})
		if err != nil {
			log.Fatal(err)
		}

		filterFunc := func(ctx context.Context, instance []discovery.Instance) []discovery.Instance {
			var res []discovery.Instance
			for _, ins := range instance {
				if v, ok := ins.Tag("Cluster"); ok && v == "StudentCluster" {
					// only match tag with {tagKey: tagValues[0]}
					res = append(res, ins)
				}
			}
			return res
		}
		// Construct the filterRule
		filterRule := &FilterRule{Name: "rule-name", Funcs: []FilterFunc{filterFunc}}
		// build rule based resolver
		rbr := NewRuleBasedResolver(r, filterRule)

		// service discovery
		ctx := context.Background()
		ei := rpcinfo.NewEndpointInfo("StudentService", "", nil, nil)
		desc := rbr.Target(ctx, ei)
		res, err := rbr.Resolve(ctx, desc)
		if err != nil {
			panic(err)
		}

		// the instance should match the filter rule
		v, _ := res.Instances[0].Tag("Cluster")
		fmt.Println(fmt.Sprintf("[Resolver]: get instance with tag, [Cluster:%s]", v))

		cfg := connpool.IdleConfig{
			MaxIdlePerAddress: 1000,
			MaxIdleGlobal:     10000,
			MaxIdleTimeout:    60 * time.Second,
		}

		queryClient, err = genericclient.NewClient("StudentService", g,
			client.WithResolver(rbr), client.WithLoadBalancer(new(randomBalancer)), client.WithLongConnection(cfg))
		if err != nil {
			panic(err)
		}
	} else {
		err = queryProvider.UpdateIDL(thriftContent, nil)
		if err != nil {
			panic(err)
		}
	}
	return &queryClient
}

// Register .
// @router /add-student-info [POST]
func Register(ctx context.Context, c *app.RequestContext) {
	httpReq, err := adaptor.GetCompatRequest(c.GetRequest())
	if err != nil {
		panic(err)
	}

	re, _ := generic.FromHTTPRequest(httpReq)

	bytes, err := json.Marshal(re.Body)

	resp, err := (*getRegisterClient()).GenericCall(ctx, "Register", string(bytes[:]))
	if err != nil {
		panic(err)
	}

	c.JSON(consts.StatusOK, resp)
}

// Query .
// @router /query [GET]
func Query(ctx context.Context, c *app.RequestContext) {

	httpReq, err := adaptor.GetCompatRequest(c.GetRequest())
	if err != nil {
		panic(err)
	}

	req, _ := generic.FromHTTPRequest(httpReq)

	resp, err := (*getQueryRegister()).GenericCall(ctx, "", req)
	if err != nil {
		panic(err)
	}

	c.JSON(consts.StatusOK, resp)
}

// Port .
// @router /port [GET]
func Port(ctx context.Context, c *app.RequestContext) {
	httpReq, err := adaptor.GetCompatRequest(c.GetRequest())
	if err != nil {
		panic(err)
	}

	req, _ := generic.FromHTTPRequest(httpReq)

	resp, err := (*getQueryRegister()).GenericCall(ctx, "", req)
	if err != nil {
		panic(err)
	}

	c.JSON(consts.StatusOK, resp)
}
